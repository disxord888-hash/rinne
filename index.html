<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>輪廻</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Antique&family=Noto+Serif+JP:wght@700;900&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Zen Antique', serif;
            overflow: hidden;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            padding: 1rem;
        }

        .player-wrapper {
            width: 100%;
            max-width: 900px;
            aspect-ratio: 16 / 9;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(80, 0, 0, 0.6);
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .rinne-counter {
            text-align: center;
            position: relative;
            z-index: 100000;
        }

        .rinne-label {
            font-size: 1.5rem;
            color: #8b0000;
            letter-spacing: 0.5em;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(139, 0, 0, 0.7);
        }

        .rinne-count {
            font-family: 'Noto Serif JP', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, #4a0000 0%, #8b0000 50%, #5c1a1a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                filter: brightness(1);
            }

            50% {
                opacity: 0.8;
                filter: brightness(1.3);
            }
        }

        .rinne-count.flash {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% {
                transform: scale(1.2);
                filter: brightness(2);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        /* 背景エフェクト */
        .bg-glow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, rgba(80, 0, 0, 0.25) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        /* RETRY NOW エフェクト */
        .retry-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(139, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.9) 100%);
            pointer-events: none;
            z-index: 99999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .retry-flash.active {
            animation: retryFlash 1.5s ease-out;
        }

        @keyframes retryFlash {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        /* 赤いノイズオーバーレイ */
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99998;
            opacity: 0;
            background:
                url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"),
                linear-gradient(rgba(139, 0, 0, 0.3), rgba(80, 0, 0, 0.3));
            background-blend-mode: overlay;
        }

        /* プレイヤー操作ブロッカー */
        .player-blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* テキスト背後の赤背景 */
        .red-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(139, 0, 0, 1);
            pointer-events: none;
            z-index: 99999;
            /* ノイズ(99998)より上、文字(100000)より下 */
            opacity: 0;
            mix-blend-mode: multiply;
            /* 画面全体を赤く染める */
            transition: opacity 0.5s ease;
        }

        /* スタートボタンオーバーレイ */
        .start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            transition: opacity 0.5s ease;
        }

        .start-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #start-btn {
            background: rgba(139, 0, 0, 0.3);
            border: 2px solid #8b0000;
            color: #ffcccc;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            padding: 1rem 3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        #start-btn:hover {
            background: rgba(139, 0, 0, 0.6);
            box-shadow: 0 0 40px rgba(139, 0, 0, 0.8);
            transform: scale(1.05);
            color: #fff;
        }
    </style>
</head>

<body>
    <div class="bg-glow"></div>
    <div class="retry-flash" id="retryFlash"></div>
    <div class="noise-overlay" id="noise"></div>

    <div class="container">
        <div class="player-wrapper">
            <div id="player"></div>
            <div class="player-blocker"></div>
            <div class="start-overlay" id="start-overlay">
                <button id="start-btn">RETRY NOW</button>
            </div>
        </div>

        <!-- 背景赤レイヤー -->
        <div class="red-bg" id="red-bg"></div>

        <div class="rinne-counter">
            <div class="rinne-label">輪廻回数</div>
            <div class="rinne-count" id="count">0</div>
        </div>
    </div>

    <script>
        // YouTube IFrame API
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        let player;
        let rinneCount = 0;
        let loopInterval;

        const VIDEO_ID = '3iUgKH8c7p4';
        const START_TIME = 12; // 0:12
        const END_TIME = 13;   // 0:13

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: VIDEO_ID,
                playerVars: {
                    autoplay: 0, // 自動再生はボタンで制御
                    start: START_TIME,
                    controls: 0, // コントロールなし
                    disablekb: 1, // キーボード無効
                    fs: 0, // 全画面ボタンなし
                    modestbranding: 1,
                    rel: 0,
                    playsinline: 1,
                    iv_load_policy: 3 // アノテーションなし
                },
                events: {
                    onReady: onPlayerReady,
                    onStateChange: onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            // スタートボタンの制御
            const startBtn = document.getElementById('start-btn');
            const overlay = document.getElementById('start-overlay');

            startBtn.addEventListener('click', () => {
                event.target.playVideo();
                overlay.classList.add('hidden');
                // ループチェック開始
                startLoopCheck();
            });

            // 最初のシーク位置をセット
            event.target.seekTo(START_TIME, true);
        }

        function onPlayerStateChange(event) {
            // 再生中のみループチェック
            if (event.data === YT.PlayerState.PLAYING) {
                startLoopCheck();
            } else {
                stopLoopCheck();
            }
        }

        function startLoopCheck() {
            if (loopInterval) return;
            loopInterval = setInterval(checkLoop, 50);
        }

        function stopLoopCheck() {
            if (loopInterval) {
                clearInterval(loopInterval);
                loopInterval = null;
            }
        }

        let isSeeking = false;

        function checkLoop() {
            if (!player || typeof player.getCurrentTime !== 'function' || isSeeking) return;

            const currentTime = player.getCurrentTime();

            if (currentTime >= END_TIME) {
                isSeeking = true; // ロック
                rinneCount++;
                updateCounter();
                player.seekTo(START_TIME, true);

                // シーク完了待ちのロック解除
                setTimeout(() => {
                    isSeeking = false;
                }, 500);
            }
        }

        function updateCounter() {
            const countEl = document.getElementById('count');
            const labelEl = document.querySelector('.rinne-label');
            countEl.textContent = rinneCount.toLocaleString();

            // フラッシュアニメーション
            countEl.classList.remove('flash');
            void countEl.offsetWidth; // リフロー強制
            countEl.classList.add('flash');

            // 赤いノイズ強度を更新 (輪廻回数 / 4)%
            const noiseOpacity = Math.min(rinneCount / 4, 100) / 100;
            document.getElementById('noise').style.opacity = noiseOpacity;

            // 輪廻回数と数字を少しずつ黒くする
            // 0回: #8b0000 (DarkRed) -> 400回: #000000 (Black)
            const darkness = Math.min(rinneCount / 400, 1);
            // 赤成分: 139 (8B) -> 0
            const redComponent = Math.floor(139 * (1 - darkness));
            const color = `rgb(${redComponent}, 0, 0)`;

            countEl.style.color = color;
            countEl.style.webkitTextFillColor = color; // グラデーション上書き用
            countEl.style.background = 'none'; // 背景グラデーションを無効化
            labelEl.style.color = color;
            labelEl.style.textShadow = `0 0 20px rgba(${redComponent}, 0, 0, 0.7)`;

            // 背景を少しずつ赤くする (文字の後ろ)
            // (輪廻回数 / 3)%
            const bgOpacity = Math.min(rinneCount / 3, 80) / 100;
            document.getElementById('red-bg').style.opacity = bgOpacity;

            // サウンドエフェクト（150回まではだんだん強く、最大30%）
            if (rinneCount > 0) {
                let volume;
                if (rinneCount <= 150) {
                    // 0〜150: だんだん強くなる (0.05 → 0.3)
                    volume = 0.05 + (rinneCount / 150) * 0.25;
                } else {
                    // 150以降: 30%を維持
                    volume = 0.3;
                }
                playLoopSound(volume);
            }
        }

        // ループ時のサウンドエフェクト（強い音割れ付き）
        function playLoopSound(volumeLevel = 0.5) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // ディストーション（音割れ）を作成 - 音量に応じて歪みも変化
            function makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((Math.PI + amount) * x) / (Math.PI + amount * Math.abs(x));
                }
                return curve;
            }

            const distortionAmount = 100 + volumeLevel * 400; // 音量に応じてディストーションも変化
            const distortion = audioCtx.createWaveShaper();
            distortion.curve = makeDistortionCurve(distortionAmount);
            distortion.oversample = '4x';

            // 低い不協和音（複数重ねる）
            const frequencies = [55, 58, 41, 62];

            frequencies.forEach((freq, index) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.type = index % 2 === 0 ? 'sawtooth' : 'square';
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freq * 0.7, audioCtx.currentTime + 0.6);

                gainNode.gain.setValueAtTime(0.4 * volumeLevel, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);

                oscillator.connect(gainNode);
                gainNode.connect(distortion);

                oscillator.start(audioCtx.currentTime + index * 0.02);
                oscillator.stop(audioCtx.currentTime + 0.6);
            });

            // ノイズも追加（音割れ感を強化）
            const bufferSize = audioCtx.sampleRate * 0.3;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.3 * volumeLevel, audioCtx.currentTime);
            noiseSource.connect(noiseGain);
            noiseGain.connect(distortion);
            noiseSource.start();

            // マスターゲイン
            const masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(0.5 * volumeLevel, audioCtx.currentTime);

            distortion.connect(masterGain);
            masterGain.connect(audioCtx.destination);
        }

        // ===== RETRY NOW イースターエッグ =====
        const RETRY_SEQUENCE = ['R', 'E', 'T', 'R', 'Y', 'N', 'O', 'W'];
        let keySequence = [];
        let keyTimeout = null;

        // Web Audio API でサウンドエフェクト
        function playRetrySound() {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // 不協和音と低音の重なり
            const frequencies = [110, 138.59, 164.81, 55];

            frequencies.forEach((freq, index) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.type = index === 3 ? 'sawtooth' : 'sine';
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.start(audioCtx.currentTime + index * 0.05);
                oscillator.stop(audioCtx.currentTime + 1.5);
            });

            // ノイズ音
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            noiseSource.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseSource.start();
        }

        function triggerRetryNow() {
            // 現在の100,000 に足して 合計 207944155 にする
            // 207944155 - 100000 = 207844155
            rinneCount += 207844155;
            updateCounter();

            // フラッシュエフェクト
            const flashEl = document.getElementById('retryFlash');
            flashEl.classList.remove('active');
            void flashEl.offsetWidth;
            flashEl.classList.add('active');

            // サウンド
            playRetrySound();

            console.log('RETRY NOW activated! +207,944,155');
        }

        document.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();

            // タイムアウトリセット
            if (keyTimeout) clearTimeout(keyTimeout);
            keyTimeout = setTimeout(() => {
                keySequence = [];
            }, 2000);

            // 次に必要なキーをチェック
            const nextIndex = keySequence.length;
            if (key === RETRY_SEQUENCE[nextIndex]) {
                keySequence.push(key);

                // 段階的な加算 (指定された累計値になるように加算)
                // R: 計1       (+1)
                // E: 計5       (+4)
                // T: 計15      (+10)
                // R: 計50      (+35)
                // Y: 計200     (+150)
                // N: 計4000    (+3800)
                // O: 計100000  (+96000)
                // W: Final 計207944155 (+207844155)

                let addCount = 0;
                let soundFreq = 0;

                switch (keySequence.length) {
                    case 1: addCount = 1; soundFreq = 440; break;      // R (+1)
                    case 2: addCount = 4; soundFreq = 554; break;      // E (+4) -> 計5
                    case 3: addCount = 10; soundFreq = 659; break;     // T (+10) -> 計15
                    case 4: addCount = 35; soundFreq = 880; break;     // R (+35) -> 計50
                    case 5: addCount = 150; soundFreq = 1661; break;   // Y (+150) -> 計200
                    case 6: addCount = 3800; soundFreq = 2217; break;  // N (+3800) -> 計4000
                    case 7: addCount = 96000; soundFreq = 3322; break; // O (+96000) -> 計100000
                }

                if (addCount > 0) {
                    rinneCount += addCount;
                    updateCounter();
                    // 小さなタイプ音
                    playTypeSound(soundFreq);
                }

                // 全シーケンス完了 (W)
                if (keySequence.length === RETRY_SEQUENCE.length) {
                    triggerRetryNow();
                    keySequence = [];
                }
            } else if (key === RETRY_SEQUENCE[0]) {
                // Rでリセットして再開 (+1)
                keySequence = [key];
                rinneCount += 1;
                updateCounter();
                playTypeSound(440);
            } else {
                keySequence = [];
            }
        });

        function playTypeSound(freq) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        }
    </script>
</body>

</html>
